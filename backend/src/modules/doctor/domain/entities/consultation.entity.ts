/**
 * Consultation Domain Entity
 * 
 * Represents a clinical encounter between doctor and patient.
 * Created FROM a confirmed appointment (appointment-first model).
 * 
 * @domain Doctor
 * @aggregate-root Consultation
 */

export enum ConsultationStatus {
  SCHEDULED = 'SCHEDULED',
  IN_PROGRESS = 'IN_PROGRESS',
  COMPLETED = 'COMPLETED',
  CANCELLED = 'CANCELLED',
  REQUIRES_FOLLOW_UP = 'REQUIRES_FOLLOW_UP',
}

export enum ConsultationType {
  INITIAL = 'INITIAL',
  FOLLOW_UP = 'FOLLOW_UP',
  PRE_OP = 'PRE_OP',
  POST_OP = 'POST_OP',
  EMERGENCY = 'EMERGENCY',
}

export interface ConsultationProps {
  id: string;
  consultationNumber: string;
  patientId: string;
  doctorId: string;
  appointmentId: string;
  consultationType: ConsultationType;
  consultationDate: Date;
  status: ConsultationStatus;
  chiefComplaint?: string;
  diagnosis?: string;
  notes?: string;
  followUpRequired: boolean;
  followUpDate?: Date;
  billable: boolean;
  billed: boolean;
  completedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
  createdBy?: string;
  updatedBy?: string;
  version: number;
}

/**
 * Consultation Domain Entity
 * 
 * Business rules:
 * - Must be linked to a confirmed appointment
 * - Can only be completed by the assigned doctor
 * - Immutable once completed (except for amendments)
 * - Follow-up consultations must reference original consultation
 */
export class Consultation {
  private constructor(private readonly props: ConsultationProps) {}

  /**
   * Factory method to create new consultation from appointment
   */
  static create(params: {
    consultationNumber: string;
    patientId: string;
    doctorId: string;
    appointmentId: string;
    consultationType: ConsultationType;
    consultationDate: Date;
    chiefComplaint?: string;
    createdBy: string;
  }): Consultation {
    return new Consultation({
      id: '', // Generated by repository
      consultationNumber: params.consultationNumber,
      patientId: params.patientId,
      doctorId: params.doctorId,
      appointmentId: params.appointmentId,
      consultationType: params.consultationType,
      consultationDate: params.consultationDate,
      status: ConsultationStatus.SCHEDULED,
      chiefComplaint: params.chiefComplaint,
      followUpRequired: false,
      billable: true,
      billed: false,
      createdAt: new Date(),
      updatedAt: new Date(),
      createdBy: params.createdBy,
      version: 1,
    });
  }

  /**
   * Reconstitute from persistence
   */
  static reconstitute(props: ConsultationProps): Consultation {
    return new Consultation(props);
  }

  // Getters
  get id(): string {
    return this.props.id;
  }

  get consultationNumber(): string {
    return this.props.consultationNumber;
  }

  get patientId(): string {
    return this.props.patientId;
  }

  get doctorId(): string {
    return this.props.doctorId;
  }

  get appointmentId(): string {
    return this.props.appointmentId;
  }

  get consultationType(): ConsultationType {
    return this.props.consultationType;
  }

  get status(): ConsultationStatus {
    return this.props.status;
  }

  get chiefComplaint(): string | undefined {
    return this.props.chiefComplaint;
  }

  get diagnosis(): string | undefined {
    return this.props.diagnosis;
  }

  get notes(): string | undefined {
    return this.props.notes;
  }

  get followUpRequired(): boolean {
    return this.props.followUpRequired;
  }

  get followUpDate(): Date | undefined {
    return this.props.followUpDate;
  }

  get billable(): boolean {
    return this.props.billable;
  }

  get billed(): boolean {
    return this.props.billed;
  }

  get completedAt(): Date | undefined {
    return this.props.completedAt;
  }

  get version(): number {
    return this.props.version;
  }

  get consultationDate(): Date {
    return this.props.consultationDate;
  }

  get createdBy(): string | undefined {
    return this.props.createdBy;
  }

  // Business Methods

  /**
   * Start consultation (doctor begins examination)
   */
  start(doctorId: string): void {
    if (this.status !== ConsultationStatus.SCHEDULED) {
      throw new Error(
        `Cannot start consultation in ${this.status} status. Must be SCHEDULED.`,
      );
    }

    if (this.doctorId !== doctorId) {
      throw new Error(
        `Only assigned doctor ${this.doctorId} can start this consultation`,
      );
    }

    this.props.status = ConsultationStatus.IN_PROGRESS;
    this.props.updatedAt = new Date();
  }

  /**
   * Update clinical findings during consultation
   */
  updateClinicalFindings(params: {
    chiefComplaint?: string;
    diagnosis?: string;
    notes?: string;
    doctorId: string;
  }): void {
    if (this.status !== ConsultationStatus.IN_PROGRESS) {
      throw new Error(
        `Cannot update clinical findings in ${this.status} status. Must be IN_PROGRESS.`,
      );
    }

    if (this.doctorId !== params.doctorId) {
      throw new Error(
        `Only assigned doctor ${this.doctorId} can update clinical findings`,
      );
    }

    if (params.chiefComplaint !== undefined) {
      this.props.chiefComplaint = params.chiefComplaint;
    }
    if (params.diagnosis !== undefined) {
      this.props.diagnosis = params.diagnosis;
    }
    if (params.notes !== undefined) {
      this.props.notes = params.notes;
    }

    this.props.updatedAt = new Date();
  }

  /**
   * Complete consultation
   */
  complete(params: {
    doctorId: string;
    diagnosis?: string;
    notes?: string;
    followUpRequired?: boolean;
    followUpDate?: Date;
  }): void {
    if (this.status !== ConsultationStatus.IN_PROGRESS) {
      throw new Error(
        `Cannot complete consultation in ${this.status} status. Must be IN_PROGRESS.`,
      );
    }

    if (this.doctorId !== params.doctorId) {
      throw new Error(
        `Only assigned doctor ${this.doctorId} can complete this consultation`,
      );
    }

    if (!this.props.diagnosis && !params.diagnosis) {
      throw new Error('Diagnosis is required to complete consultation');
    }

    if (params.diagnosis) {
      this.props.diagnosis = params.diagnosis;
    }
    if (params.notes) {
      this.props.notes = params.notes;
    }

    this.props.followUpRequired = params.followUpRequired ?? false;
    this.props.followUpDate = params.followUpDate;

    this.props.status = params.followUpRequired
      ? ConsultationStatus.REQUIRES_FOLLOW_UP
      : ConsultationStatus.COMPLETED;

    this.props.completedAt = new Date();
    this.props.updatedAt = new Date();
  }

  /**
   * Cancel consultation
   */
  cancel(doctorId: string, reason: string): void {
    if (this.status === ConsultationStatus.COMPLETED) {
      throw new Error('Cannot cancel completed consultation');
    }

    if (this.doctorId !== doctorId) {
      throw new Error(
        `Only assigned doctor ${this.doctorId} can cancel this consultation`,
      );
    }

    if (!reason || reason.trim().length === 0) {
      throw new Error('Cancellation reason is required');
    }

    this.props.status = ConsultationStatus.CANCELLED;
    this.props.notes = `${this.props.notes || ''}\n\nCANCELLED: ${reason}`.trim();
    this.props.updatedAt = new Date();
  }

  /**
   * Mark as billed
   */
  markAsBilled(): void {
    if (!this.billable) {
      throw new Error('This consultation is not billable');
    }

    if (this.billed) {
      throw new Error('This consultation has already been billed');
    }

    this.props.billed = true;
    this.props.updatedAt = new Date();
  }

  /**
   * Check if consultation is editable
   */
  isEditable(): boolean {
    return (
      this.status === ConsultationStatus.SCHEDULED ||
      this.status === ConsultationStatus.IN_PROGRESS
    );
  }

  /**
   * Check if consultation is completed
   */
  isCompleted(): boolean {
    return (
      this.status === ConsultationStatus.COMPLETED ||
      this.status === ConsultationStatus.REQUIRES_FOLLOW_UP
    );
  }

  /**
   * Check if doctor has access
   */
  canBeAccessedBy(doctorId: string): boolean {
    return this.doctorId === doctorId;
  }

  /**
   * Get all properties (for persistence)
   */
  toObject(): ConsultationProps {
    return { ...this.props };
  }

  /**
   * Increment version for optimistic locking
   */
  incrementVersion(): void {
    this.props.version += 1;
  }
}


