// Medical Records: Append-Only, Versioned Clinical Data
// Immutable clinical documentation with amendment tracking

model MedicalRecord {
  id          String   @id @default(uuid()) @db.Uuid
  recordNumber String  @unique @db.VarChar(50) // MRN or similar
  patientId   String   @db.Uuid // Reference to Patient
  
  // Identity data separated from clinical data
  dateOfBirth DateTime? @db.Date
  gender      String?   @db.VarChar(20)
  bloodType   String?   @db.VarChar(10)
  
  status      String    @default("ACTIVE") @db.VarChar(50) // ACTIVE, ARCHIVED, MERGED
  mergedInto  String?   @db.Uuid // If merged, reference to primary record
  
  // Audit
  createdAt   DateTime  @default(now()) @db.Timestamptz(6)
  updatedAt   DateTime  @updatedAt @db.Timestamptz(6)
  createdBy   String?   @db.Uuid
  updatedBy   String?   @db.Uuid
  version     Int       @default(1)
  
  // Relations
  patient     Patient   @relation(fields: [patientId], references: [id], onDelete: Restrict)
  notes       ClinicalNote[]
  attachments MedicalRecordAttachment[]
  billLineItems BillLineItem[]
  mergeHistory RecordMergeHistory[] @relation("SourceRecord")
  mergedRecords RecordMergeHistory[] @relation("TargetRecord")
  
  @@index([recordNumber])
  @@index([patientId])
  @@index([status])
  @@index([mergedInto])
  @@map("medical_records")
}

model ClinicalNote {
  id          String   @id @default(uuid()) @db.Uuid
  recordId    String   @db.Uuid
  noteType    String   @db.VarChar(100) // PROGRESS, OPERATIVE, CONSULTATION, DISCHARGE
  category    String?  @db.VarChar(100) // SOAP, HPI, etc.
  
  // Append-only: content is immutable
  content     String   @db.Text
  contentHash String   @db.VarChar(64) // SHA-256 for integrity verification
  
  // Metadata
  encounterDate DateTime? @db.Timestamptz(6)
  authoredAt    DateTime  @default(now()) @db.Timestamptz(6)
  authoredBy    String    @db.Uuid // User ID
  
  // Versioning support
  isAmendment   Boolean   @default(false)
  amendsNoteId  String?   @db.Uuid // Reference to amended note
  amendmentReason String? @db.Text
  
  // Audit
  createdAt   DateTime  @default(now()) @db.Timestamptz(6)
  version     Int       @default(1)
  
  // Relations
  record      MedicalRecord @relation(fields: [recordId], references: [id], onDelete: Cascade)
  amendedNote ClinicalNote? @relation("NoteAmendment", fields: [amendsNoteId], references: [id])
  amendments  ClinicalNote[] @relation("NoteAmendment")
  
  @@index([recordId])
  @@index([authoredBy])
  @@index([authoredAt])
  @@index([noteType])
  @@index([amendsNoteId])
  @@index([contentHash])
  // Note: Full-text search can be added via raw SQL migration:
  // CREATE INDEX clinical_notes_content_fulltext_idx ON clinical_notes USING gin(to_tsvector('english', content));
  @@map("clinical_notes")
}

model MedicalRecordAttachment {
  id          String   @id @default(uuid()) @db.Uuid
  recordId    String   @db.Uuid
  fileName    String   @db.VarChar(500)
  filePath    String   @db.VarChar(1000) // Storage location (S3, local, etc.)
  fileSize    BigInt   @db.BigInt
  mimeType    String   @db.VarChar(100)
  
  // Integrity
  fileHash    String   @db.VarChar(64) // SHA-256
  checksumVerifiedAt DateTime? @db.Timestamptz(6)
  
  // Scoped access
  accessLevel String   @default("RESTRICTED") @db.VarChar(50) // PUBLIC, RESTRICTED, CONFIDENTIAL
  description String?  @db.Text
  
  // Audit
  createdAt   DateTime  @default(now()) @db.Timestamptz(6)
  createdBy   String    @db.Uuid
  version     Int       @default(1)
  
  // Relations
  record      MedicalRecord @relation(fields: [recordId], references: [id], onDelete: Cascade)
  
  // Note: Access logs tracked via DataAccessLog.resourceType + resourceId (polymorphic)
  
  @@index([recordId])
  @@index([createdBy])
  @@index([accessLevel])
  @@index([fileHash])
  @@map("medical_record_attachments")
}

// CRITICAL: Immutable merge history for legal defensibility
// Record merges must be event-anchored and reversible for legal discovery
model RecordMergeHistory {
  id          String   @id @default(uuid()) @db.Uuid
  
  // Merge details
  sourceRecordId String @db.Uuid // Record being merged FROM
  targetRecordId String @db.Uuid // Record being merged INTO (primary)
  
  // CRITICAL: Event anchoring
  // Every merge operation must be triggered by a DomainEvent
  triggeringEventId String @db.Uuid // DomainEvent that authorized merge
  
  // Merge context
  reason      String?  @db.Text // Why records were merged
  mergedBy    String?  @db.Uuid // User who performed merge
  
  // Reversal tracking (if merge was undone)
  reversedAt  DateTime? @db.Timestamptz(6)
  reversalEventId String? @db.Uuid // DomainEvent that reversed merge
  reversedBy  String?  @db.Uuid
  
  // Audit (immutable)
  mergedAt    DateTime @default(now()) @db.Timestamptz(6)
  version     Int      @default(1) // Always 1 - immutable
  
  // Relations
  sourceRecord MedicalRecord @relation("SourceRecord", fields: [sourceRecordId], references: [id], onDelete: Restrict)
  targetRecord MedicalRecord @relation("TargetRecord", fields: [targetRecordId], references: [id], onDelete: Restrict)
  triggeringEvent DomainEvent @relation("RecordMergeEvent", fields: [triggeringEventId], references: [id])
  reversalEvent DomainEvent? @relation("RecordMergeReversalEvent", fields: [reversalEventId], references: [id])
  
  // INVARIANT: This record is IMMUTABLE after creation
  // Never UPDATE or DELETE - only INSERT
  // To reverse: create new RecordMergeHistory with reversed source/target
  // Or: update reversal fields via new DomainEvent
  
  @@index([sourceRecordId])
  @@index([targetRecordId])
  @@index([triggeringEventId])
  @@index([reversalEventId])
  @@index([mergedAt])
  @@index([reversedAt])
  @@map("record_merge_history")
}

